<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Markdown Render Preview</title>
    <style>
      :root {
        --bg: #0a0a0a;
        --surface: #111111;
        --surface-2: #0f0f0f;
        --border: #262626;
        --text: #c8c8c8;
        --text-strong: #f0f0f0;
        --text-muted: #8c8c8c;
        --accent: #b6b6b6;
        --accent-soft: rgba(94, 176, 255, 0.18);
        --table-head: #171b20;
        --table-row: #11161b;
        --table-row-alt: #101319;
        --task-bg: #121a21;
        --task-border: #283a4a;
        --task-done: #7f98ab;
        --code-bg: #0b0b0b;
        --inline-bg: #171717;
        --warn-bg: #201516;
        --warn-border: #4d3033;
        --warn-text: #e3b9bd;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        color: var(--text);
        font-family: "JetBrains Mono", "Fira Code", "IBM Plex Mono", "Cascadia Code", "SFMono-Regular", Consolas, monospace;
        font-size: 15px;
        background: var(--bg);
      }

      .shell {
        max-width: 860px;
        margin: 0 auto;
        padding: 18px 14px 28px;
      }

      .status-card {
        border: 1px solid var(--border);
        background: transparent;
        border-radius: 4px;
        padding: 8px 10px;
        margin-bottom: 10px;
      }

      .status-title {
        margin: 0;
        font-size: 0.74rem;
        letter-spacing: 0.04em;
        color: var(--text-muted);
      }

      .status-line {
        margin: 4px 0 0;
        color: var(--text-strong);
        font-size: 0.84rem;
      }

      #preview-root {
        border: 1px solid var(--border);
        border-radius: 4px;
        background: var(--surface-2);
        padding: 20px 22px;
        min-height: 72vh;
      }

      #md-root {
        line-height: 1.62;
        font-size: 0.95rem;
      }

      #md-root [data-line] {
        transition: background-color 90ms linear, box-shadow 90ms linear;
      }

      #md-root .is-cursor-line {
        background: rgba(170, 170, 170, 0.12);
        border-radius: 0;
        display: block;
        width: 100%;
      }

      #md-root h1,
      #md-root h2,
      #md-root h3,
      #md-root h4,
      #md-root h5,
      #md-root h6 {
        color: var(--text-strong);
        line-height: 1.28;
        margin-top: 1.4em;
        margin-bottom: 0.4em;
      }

      #md-root h1 {
        border-bottom: 1px solid var(--border);
        padding-bottom: 0.25em;
      }

      #md-root a {
        color: #58a6ff;
        text-decoration: underline;
      }

      #md-root img {
        display: block;
        max-width: 100%;
        height: auto;
        margin: 0.75em 0;
        border-radius: 4px;
      }

      #md-root blockquote {
        border-left: 2px solid var(--accent);
        margin-left: 0;
        padding: 0.2em 0 0.2em 0.9em;
        color: #ababab;
      }

      #md-root code,
      #md-root pre,
      #md-root .mono {
        font-family: "JetBrains Mono", "Fira Code", "IBM Plex Mono", "Cascadia Code", "SFMono-Regular", Consolas, monospace;
      }

      #md-root :not(pre) > code {
        background: var(--inline-bg);
        color: #cfe2ff;
        padding: 0.15em 0.35em;
        border-radius: 3px;
        border: 1px solid var(--border);
      }

      #md-root pre {
        position: relative;
        border: 1px solid var(--border);
        background: var(--code-bg);
        border-radius: 4px;
        padding: 24px 14px 12px;
        overflow-x: auto;
      }

      #md-root pre[data-lang]::before {
        content: attr(data-lang);
        position: absolute;
        top: 6px;
        right: 10px;
        font-size: 0.68rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--text-muted);
      }

      #md-root pre code {
        color: #d7e8ff;
      }

      #md-root .tok-comment {
        color: #6f89ab;
      }

      #md-root .tok-keyword {
        color: #ca9eff;
        font-weight: 600;
      }

      #md-root .tok-string {
        color: #9be97f;
      }

      #md-root .tok-number {
        color: #ffbe78;
      }

      #md-root .tok-function {
        color: #61d4ff;
      }

      #md-root .tok-constant {
        color: #ff9ecb;
      }

      #md-root .tok-variable {
        color: #8fe3d2;
      }

      #md-root .tok-property {
        color: #f6dca3;
      }

      #md-root table {
        border-collapse: separate;
        border-spacing: 0;
        width: 100%;
        background: linear-gradient(180deg, #11161a 0%, #101318 100%);
        border: 1px solid var(--border);
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.28);
      }

      #md-root td,
      #md-root th {
        border-right: 1px solid var(--border);
        border-bottom: 1px solid var(--border);
        padding: 8px 10px;
      }

      #md-root th {
        background: var(--table-head);
        color: var(--text-strong);
        text-align: left;
        letter-spacing: 0.02em;
      }

      #md-root td {
        background: var(--table-row);
      }

      #md-root tr:nth-child(even) td {
        background: var(--table-row-alt);
      }

      #md-root tr:hover td {
        background: #16222d;
      }

      #md-root tr > :last-child {
        border-right: 0;
      }

      #md-root table tr:last-child > * {
        border-bottom: 0;
      }

      #md-root hr {
        border: 0;
        border-top: 1px solid var(--border);
      }

      #md-root input[type="checkbox"] {
        appearance: none;
        -webkit-appearance: none;
        width: 15px;
        height: 15px;
        border: 1.5px solid var(--text-muted);
        border-radius: 4px;
        background: var(--bg);
        vertical-align: middle;
        margin-right: 8px;
        cursor: default;
        position: relative;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
      }

      #md-root input[type="checkbox"]:checked {
        background: #5eb0ff;
        border-color: #5eb0ff;
      }

      #md-root input[type="checkbox"]:checked::after {
        content: '';
        position: absolute;
        left: 4px;
        top: 1px;
        width: 4px;
        height: 8px;
        border: solid var(--bg);
        border-width: 0 2px 2px 0;
        transform: rotate(45deg);
      }

      #md-root ul,
      #md-root ol {
        padding-left: 1.2em;
      }

      #md-root li {
        margin: 0.26em 0;
      }

      #md-root li.task-list-item,
      #md-root ul.contains-task-list > li {
        list-style: none;
        margin-left: -0.5em;
        padding: 0.32em 0.55em 0.35em 0.45em;
        border: 1px solid var(--task-border);
        border-radius: 6px;
        background: linear-gradient(180deg, var(--task-bg), #10171e);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.24);
      }

      #md-root li.task-list-item + li.task-list-item,
      #md-root ul.contains-task-list > li + li {
        margin-top: 0.42em;
      }

      #md-root li.task-list-item:has(> input[type="checkbox"]:checked),
      #md-root ul.contains-task-list > li:has(> input[type="checkbox"]:checked) {
        border-color: #35556e;
        background: linear-gradient(180deg, rgba(38, 65, 87, 0.55), var(--accent-soft));
        color: var(--task-done);
      }

      .warning {
        margin-top: 10px;
        border-radius: 4px;
        border: 1px solid var(--warn-border);
        background: var(--warn-bg);
        color: var(--warn-text);
        padding: 8px 10px;
        display: none;
      }

      @media (max-width: 900px) {
        .shell {
          padding: 10px;
        }

        #preview-root {
          padding: 16px 14px;
          border-radius: 6px;
          min-height: calc(100vh - 80px);
        }
      }
    </style>
  </head>
  <body>
    <main class="shell">
      <section class="status-card">
        <p class="status-title">Καλησπέρα</p>
        <p id="status-line" class="status-line">Connecting...</p>
      </section>
      <section id="preview-root">
        <article id="md-root">
          <p data-line="1">Waiting for snapshot...</p>
        </article>
      </section>
      <section id="warning" class="warning"></section>
    </main>

    <script>
      (() => {
        const AUTO_SCROLL = __AUTO_SCROLL__;
        const COMFORT_TOP = Number("__SCROLL_TOP__");
        const COMFORT_BOTTOM = Number("__SCROLL_BOTTOM__");
        const FOLLOW_RATIO = Math.max(0.05, Math.min(0.95, (COMFORT_TOP + COMFORT_BOTTOM) / 2));

        const statusLine = document.getElementById("status-line");
        const warning = document.getElementById("warning");
        const previewRoot = document.getElementById("preview-root");

        let currentArticle = document.getElementById("md-root");
        let lineAnchors = [];
        let latestCursorLine = null;
        let activeLineElement = null;
        let manualScrollCooldownUntil = 0;
        let source = null;
        let followTargetTop = null;
        let followVelocity = 0;
        let followFrame = 0;
        let followLastTs = 0;

        const search = new URLSearchParams(window.location.search);
        const token = search.get("token");
        const bufnr = search.get("buf");

        const LANGUAGE_ALIASES = Object.freeze({
          rs: "rust",
          js: "javascript",
          jsx: "javascript",
          mjs: "javascript",
          cjs: "javascript",
          ts: "typescript",
          tsx: "typescript",
          py: "python",
          sh: "shell",
          bash: "shell",
          shellsession: "shell",
          "shell-session": "shell",
          console: "shell",
          zsh: "shell",
          fish: "shell",
          cxx: "cpp",
          cc: "cpp",
          "c++": "cpp",
          hpp: "cpp",
          hxx: "cpp",
          yml: "yaml",
          jsonc: "javascript",
          psql: "sql",
          mysql: "sql",
          plsql: "sql",
          postgresql: "sql",
          sqlite: "sql",
          plain: "plain",
          plaintext: "plain",
          md: "markdown",
          mkd: "markdown",
          mdown: "markdown",
          txt: "plain",
          text: "plain"
        });

        const KEYWORDS_BY_LANGUAGE = Object.freeze({
          rust: ["as", "async", "await", "break", "const", "continue", "crate", "else", "enum", "extern", "false", "fn", "for", "if", "impl", "in", "let", "loop", "match", "mod", "move", "mut", "pub", "ref", "return", "self", "Self", "static", "struct", "trait", "true", "type", "unsafe", "use", "where", "while"],
          javascript: ["async", "await", "break", "case", "catch", "class", "const", "continue", "default", "delete", "do", "else", "export", "extends", "false", "finally", "for", "from", "function", "if", "import", "in", "instanceof", "let", "new", "null", "of", "return", "super", "switch", "this", "throw", "true", "try", "typeof", "var", "void", "while", "yield"],
          typescript: ["abstract", "any", "as", "async", "await", "break", "case", "catch", "class", "const", "continue", "declare", "default", "do", "else", "enum", "export", "extends", "false", "finally", "for", "from", "function", "if", "implements", "import", "in", "infer", "interface", "is", "keyof", "let", "module", "namespace", "never", "new", "null", "readonly", "return", "satisfies", "static", "super", "switch", "this", "throw", "true", "try", "type", "typeof", "undefined", "var", "void", "while"],
          python: ["and", "as", "assert", "async", "await", "break", "class", "continue", "def", "del", "elif", "else", "except", "False", "finally", "for", "from", "global", "if", "import", "in", "is", "lambda", "None", "nonlocal", "not", "or", "pass", "raise", "return", "True", "try", "while", "with", "yield"],
          shell: ["case", "do", "done", "elif", "else", "esac", "export", "fi", "for", "function", "if", "in", "local", "readonly", "return", "select", "then", "until", "while"],
          go: ["break", "case", "chan", "const", "continue", "default", "defer", "else", "fallthrough", "for", "func", "go", "if", "import", "interface", "map", "package", "range", "return", "select", "struct", "switch", "type", "var"],
          c: ["auto", "break", "case", "char", "const", "continue", "default", "do", "double", "else", "enum", "extern", "float", "for", "goto", "if", "inline", "int", "long", "register", "restrict", "return", "short", "signed", "sizeof", "static", "struct", "switch", "typedef", "union", "unsigned", "void", "volatile", "while"],
          cpp: ["alignas", "alignof", "auto", "bool", "break", "case", "catch", "char", "class", "const", "constexpr", "continue", "default", "delete", "do", "double", "else", "enum", "explicit", "extern", "false", "float", "for", "friend", "goto", "if", "inline", "int", "long", "mutable", "namespace", "new", "noexcept", "nullptr", "operator", "private", "protected", "public", "return", "short", "signed", "sizeof", "static", "struct", "switch", "template", "this", "throw", "true", "try", "typedef", "typename", "union", "unsigned", "using", "virtual", "void", "volatile", "while"],
          java: ["abstract", "assert", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue", "default", "do", "double", "else", "enum", "extends", "false", "final", "finally", "float", "for", "if", "implements", "import", "instanceof", "int", "interface", "long", "native", "new", "null", "package", "private", "protected", "public", "return", "short", "static", "strictfp", "super", "switch", "synchronized", "this", "throw", "throws", "transient", "true", "try", "void", "volatile", "while"],
          ruby: ["BEGIN", "END", "alias", "and", "begin", "break", "case", "class", "def", "defined?", "do", "else", "elsif", "end", "ensure", "false", "for", "if", "in", "module", "next", "nil", "not", "or", "redo", "rescue", "retry", "return", "self", "super", "then", "true", "undef", "unless", "until", "when", "while", "yield"],
          sql: ["all", "and", "as", "asc", "between", "by", "case", "create", "delete", "desc", "distinct", "drop", "else", "end", "exists", "from", "group", "having", "in", "inner", "insert", "into", "is", "join", "left", "limit", "not", "null", "on", "or", "order", "outer", "right", "select", "set", "table", "then", "union", "update", "values", "when", "where"]
        });

        const C_STYLE_LANGUAGES = new Set(["rust", "javascript", "typescript", "go", "c", "cpp", "java", "sql"]);
        const HASH_COMMENT_LANGUAGES = new Set(["python", "shell", "ruby", "yaml", "toml", "markdown"]);
        const DASH_COMMENT_LANGUAGES = new Set(["sql", "lua", "haskell", "ada"]);
        const CASE_INSENSITIVE_KEYWORD_LANGUAGES = new Set(["sql"]);

        if (!token || !bufnr) {
          setStatus("Missing token or buffer id");
          showWarning("Preview URL is missing required query parameters.");
          return;
        }

        function setStatus(message) {
          statusLine.textContent = message;
        }

        function showWarning(message) {
          warning.style.display = "block";
          warning.textContent = message;
        }

        function clearWarning() {
          warning.style.display = "none";
          warning.textContent = "";
        }

        function hasUrlScheme(value) {
          if (/^[a-zA-Z]:[\\/]/.test(value)) {
            return false;
          }
          return /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(value);
        }

        function normalizeLocalAssetPath(raw) {
          let value = raw.trim();
          if (!value) {
            return null;
          }

          if (value.startsWith("//") || value.startsWith("#")) {
            return null;
          }

          const lower = value.toLowerCase();
          if (hasUrlScheme(value) && !lower.startsWith("file://")) {
            return null;
          }

          if (lower.startsWith("file://")) {
            value = value.slice(7);
          }

          const queryIdx = value.indexOf("?");
          if (queryIdx >= 0) {
            value = value.slice(0, queryIdx);
          }

          const hashIdx = value.indexOf("#");
          if (hashIdx >= 0) {
            value = value.slice(0, hashIdx);
          }

          if (!value) {
            return null;
          }

          try {
            value = decodeURIComponent(value);
          } catch (_error) {
            // Keep the original value when decoding fails.
          }

          return value;
        }

        function rewriteLocalImageSources(root) {
          const images = root.querySelectorAll("img[src]");
          for (const image of images) {
            const rawSrc = image.getAttribute("src");
            if (!rawSrc) {
              continue;
            }

            const normalizedPath = normalizeLocalAssetPath(rawSrc);
            if (!normalizedPath) {
              continue;
            }

            const params = new URLSearchParams({
              token,
              buf: bufnr,
              path: normalizedPath,
            });
            image.setAttribute("src", `/asset?${params.toString()}`);
          }
        }

        function escapeHtml(value) {
          return value
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#39;");
        }

        function escapeRegex(value) {
          return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }

        function normalizeLanguage(raw) {
          if (!raw) {
            return "plain";
          }

          const lowered = raw.toLowerCase().trim();
          return LANGUAGE_ALIASES[lowered] || lowered;
        }

        function languageFromClassName(className) {
          if (!className) {
            return null;
          }

          if (className.startsWith("language-")) {
            return normalizeLanguage(className.slice("language-".length));
          }

          if (className.startsWith("lang-")) {
            return normalizeLanguage(className.slice("lang-".length));
          }

          if (className.startsWith("source-")) {
            return normalizeLanguage(className.slice("source-".length));
          }

          if (className in LANGUAGE_ALIASES || className in KEYWORDS_BY_LANGUAGE) {
            return normalizeLanguage(className);
          }

          return null;
        }

        function languageFromCodeElement(codeElement) {
          for (const className of codeElement.classList) {
            const detected = languageFromClassName(className);
            if (detected) {
              return detected;
            }
          }

          const pre = codeElement.parentElement;
          if (pre && pre.tagName === "PRE") {
            const dataLang = pre.getAttribute("data-lang");
            const normalized = normalizeLanguage(dataLang || "");
            if (normalized !== "plain") {
              return normalized;
            }

            for (const className of pre.classList) {
              const detected = languageFromClassName(className);
              if (detected) {
                return detected;
              }
            }
          }

          return "plain";
        }

        function keywordRegexFor(language) {
          const words = KEYWORDS_BY_LANGUAGE[language];
          if (!words || words.length === 0) {
            return null;
          }

          const pattern = words.map((word) => escapeRegex(word)).join("|");
          const flags = CASE_INSENSITIVE_KEYWORD_LANGUAGES.has(language) ? "gi" : "g";
          return new RegExp(`\\b(?:${pattern})\\b`, flags);
        }

        function patternsForLanguage(language) {
          const patterns = [];

          if (C_STYLE_LANGUAGES.has(language)) {
            patterns.push({ regex: /\/\*[\s\S]*?\*\//g, kind: "comment" });
            patterns.push({ regex: /\/\/[^\n]*/g, kind: "comment" });
          }

          if (HASH_COMMENT_LANGUAGES.has(language)) {
            patterns.push({ regex: /#[^\n]*/g, kind: "comment" });
          }

          if (DASH_COMMENT_LANGUAGES.has(language)) {
            patterns.push({ regex: /--[^\n]*/g, kind: "comment" });
          }

          if (language === "json") {
            patterns.push({ regex: /"(?:\\.|[^"\\])*"(?=\s*:)/g, kind: "property" });
          }

          patterns.push({ regex: /`(?:\\.|[^`])*`/g, kind: "string" });
          patterns.push({ regex: /"(?:\\.|[^"\\])*"/g, kind: "string" });
          patterns.push({ regex: /'(?:\\.|[^'\\])*'/g, kind: "string" });

          if (language === "shell") {
            patterns.push({ regex: /\$\{?[A-Za-z_][A-Za-z0-9_]*\}?/g, kind: "variable" });
          }

          const keywordRegex = keywordRegexFor(language);
          if (keywordRegex) {
            patterns.push({ regex: keywordRegex, kind: "keyword" });
          }

          patterns.push({ regex: /\b(?:true|false|null|None|Some|Ok|Err)\b/g, kind: "constant" });
          patterns.push({ regex: /\b(?:0x[a-fA-F0-9]+|0b[01]+|0o[0-7]+|\d+(?:\.\d+)?(?:e[+\-]?\d+)?)\b/gi, kind: "number" });
          patterns.push({ regex: /\b[A-Za-z_][A-Za-z0-9_]*\s*(?=\()/g, kind: "function" });

          return patterns;
        }

        function highlightSource(text, language) {
          const patterns = patternsForLanguage(language);
          if (patterns.length === 0) {
            return escapeHtml(text);
          }

          let output = "";
          let index = 0;

          while (index < text.length) {
            let winner = null;

            for (const pattern of patterns) {
              pattern.regex.lastIndex = index;
              const match = pattern.regex.exec(text);
              if (!match || match[0].length === 0) {
                continue;
              }

              if (
                winner === null ||
                match.index < winner.match.index ||
                (match.index === winner.match.index && match[0].length > winner.match[0].length)
              ) {
                winner = { pattern, match };
              }
            }

            if (!winner) {
              output += escapeHtml(text.slice(index));
              break;
            }

            if (winner.match.index > index) {
              output += escapeHtml(text.slice(index, winner.match.index));
            }

            const tokenValue = winner.match[0];
            output += `<span class="tok-${winner.pattern.kind}">${escapeHtml(tokenValue)}</span>`;
            index = winner.match.index + tokenValue.length;
          }

          return output;
        }

        function applySyntaxHighlighting(root) {
          const MAX_BLOCK_CHARS = 120000;
          const blocks = root.querySelectorAll("pre code");
          for (const codeElement of blocks) {
            const raw = codeElement.textContent || "";
            if (raw.length > MAX_BLOCK_CHARS) {
              continue;
            }

            const language = languageFromCodeElement(codeElement);
            const highlighted = highlightSource(raw, language);
            codeElement.innerHTML = highlighted;

            const pre = codeElement.parentElement;
            if (pre && pre.tagName === "PRE") {
              if (language !== "plain") {
                pre.setAttribute("data-lang", language);
              } else {
                pre.removeAttribute("data-lang");
              }
            }
          }

          const inlineCodes = root.querySelectorAll(":not(pre) > code");
          for (const inlineCode of inlineCodes) {
            const raw = inlineCode.textContent || "";
            if (raw.length > 260) {
              continue;
            }
            inlineCode.innerHTML = highlightSource(raw, "plain");
          }
        }

        function updateAnchors() {
          lineAnchors = [];
          const candidates = currentArticle.querySelectorAll("[data-line]");
          for (const element of candidates) {
            const line = Number(element.getAttribute("data-line"));
            if (!Number.isNaN(line)) {
              lineAnchors.push({ line, element });
            }
          }
          lineAnchors.sort((a, b) => a.line - b.line);
        }

        function setActiveLine(line) {
          const target = findClosestAnchor(line);

          if (activeLineElement && activeLineElement !== target) {
            activeLineElement.classList.remove("is-cursor-line");
          }

          activeLineElement = target;

          if (activeLineElement) {
            activeLineElement.classList.add("is-cursor-line");
          }

          return target;
        }

        function getScrollTop() {
          return window.scrollY || document.documentElement.scrollTop || 0;
        }

        function getMaxScrollTop() {
          return Math.max(0, document.documentElement.scrollHeight - window.innerHeight);
        }

        function clampScrollTop(value) {
          return Math.max(0, Math.min(getMaxScrollTop(), value));
        }

        function stopFollowAnimation() {
          if (followFrame !== 0) {
            window.cancelAnimationFrame(followFrame);
            followFrame = 0;
          }
          followLastTs = 0;
          followVelocity = 0;
        }

        function stepFollow(ts) {
          if (followTargetTop == null) {
            stopFollowAnimation();
            return;
          }

          if (followLastTs === 0) {
            followLastTs = ts;
          }

          const dt = Math.max(1 / 120, Math.min(1 / 20, (ts - followLastTs) / 1000));
          followLastTs = ts;

          const currentTop = getScrollTop();
          const targetTop = clampScrollTop(followTargetTop);
          const distance = targetTop - currentTop;

          const distanceAbs = Math.abs(distance);
          const t = Math.min(1, distanceAbs / 1200);
          const responsiveness = 8 + 10 * t;
          const maxSpeed = 22200 + 7800 * t * t;
          const alpha = 1 - Math.exp(-responsiveness * dt);
          const unclampedStep = distance * alpha;
          const maxStep = maxSpeed * dt;
          const step = Math.max(-maxStep, Math.min(maxStep, unclampedStep));
          const nextTop = clampScrollTop(currentTop + step);

          followVelocity = step / dt;

          window.scrollTo({ top: nextTop, behavior: "auto" });

          if (Math.abs(distance) < 0.6) {
            window.scrollTo({ top: targetTop, behavior: "auto" });
            stopFollowAnimation();
            return;
          }

          followFrame = window.requestAnimationFrame(stepFollow);
        }

        function animateToScrollTop(targetTop, force) {
          const clampedTarget = clampScrollTop(targetTop);

          if (force) {
            followTargetTop = clampedTarget;
            stopFollowAnimation();
            window.scrollTo({ top: clampedTarget, behavior: "auto" });
            return;
          }

          followTargetTop = clampedTarget;
          if (followFrame === 0) {
            followFrame = window.requestAnimationFrame(stepFollow);
          }
        }

        function targetTopForElement(target) {
          const viewport = window.innerHeight || document.documentElement.clientHeight;
          const absoluteTop = getScrollTop() + target.getBoundingClientRect().top;
          return absoluteTop - viewport * FOLLOW_RATIO;
        }

        function targetTopByLineRatio(line) {
          if (!lineAnchors.length) {
            return getScrollTop();
          }

          const maxLine = Math.max(lineAnchors[lineAnchors.length - 1].line, 1);
          const ratio = Math.max(0, Math.min(1, line / maxLine));
          return getMaxScrollTop() * ratio;
        }

        function installHtml(html) {
          previewRoot.innerHTML = html;
          currentArticle = previewRoot.querySelector("#md-root") || previewRoot;
          rewriteLocalImageSources(currentArticle);
          applySyntaxHighlighting(currentArticle);
          updateAnchors();

          if (latestCursorLine != null) {
            setActiveLine(latestCursorLine);
          }
        }

        function findClosestAnchor(line) {
          if (!lineAnchors.length) {
            return null;
          }

          let lower = null;
          let higher = null;
          for (const anchor of lineAnchors) {
            if (anchor.line === line) {
              return anchor.element;
            }
            if (anchor.line < line) {
              lower = anchor;
              continue;
            }
            higher = anchor;
            break;
          }

          if (lower) {
            return lower.element;
          }
          if (higher) {
            return higher.element;
          }

          return lineAnchors[0].element;
        }

        function followCursorLine(line, force, allowDuplicate) {
          if (!line) {
            return;
          }

          if (!force && !allowDuplicate && latestCursorLine === line) {
            return;
          }

          latestCursorLine = line;
          const target = setActiveLine(line);

          if (!AUTO_SCROLL) {
            return;
          }

          if (!force && performance.now() < manualScrollCooldownUntil) {
            return;
          }

          let targetTop;
          if (!target) {
            targetTop = targetTopByLineRatio(line);
          } else {
            targetTop = targetTopForElement(target);
          }

          animateToScrollTop(targetTop, force);
        }

        function readPayload(event) {
          try {
            return JSON.parse(event.data);
          } catch (_error) {
            return null;
          }
        }

        async function loadSnapshot() {
          const response = await fetch(`/snapshot?token=${encodeURIComponent(token)}&buf=${encodeURIComponent(bufnr)}`);
          if (!response.ok) {
            throw new Error(`snapshot_http_${response.status}`);
          }

          const payload = await response.json();
          installHtml(payload.html || "<article id=\"md-root\"></article>");
          followCursorLine(payload.cursor_line, true, true);
          setStatus(`Connected - buffer ${bufnr}`);
        }

        function connectEvents() {
          if (source) {
            source.close();
          }

          source = new EventSource(`/events?token=${encodeURIComponent(token)}&buf=${encodeURIComponent(bufnr)}`);

          source.addEventListener("render_full", (event) => {
            const payload = readPayload(event);
            if (!payload) {
              return;
            }

            clearWarning();
            installHtml(payload.html || "<article id=\"md-root\"></article>");
            followCursorLine(payload.cursor_line, false, true);
            setStatus(`Live - buffer ${bufnr}`);
          });

          source.addEventListener("cursor_move", (event) => {
            const payload = readPayload(event);
            if (!payload) {
              return;
            }
            followCursorLine(payload.line, false, false);
          });

          source.addEventListener("session_end", (event) => {
            const payload = readPayload(event);
            const reason = payload && payload.reason ? payload.reason : "stopped";
            showWarning(`Session ended: ${reason}`);
            setStatus("Session ended");
            if (source) {
              source.close();
              source = null;
            }
          });

          source.addEventListener("heartbeat", () => {
            setStatus(`Live - buffer ${bufnr}`);
          });

          source.onerror = () => {
            if (source) {
              source.close();
              source = null;
            }

            setStatus("Disconnected - reconnecting...");
            setTimeout(async () => {
              try {
                await loadSnapshot();
                connectEvents();
              } catch (_error) {
                setStatus("Reconnect failed - retrying...");
                connectEvents();
              }
            }, 800);
          };
        }

        function markManualScroll() {
          manualScrollCooldownUntil = performance.now() + 220;
          followTargetTop = getScrollTop();
          stopFollowAnimation();
        }

        window.addEventListener("wheel", markManualScroll, { passive: true });
        window.addEventListener("touchmove", markManualScroll, { passive: true });
        window.addEventListener("keydown", (event) => {
          if (["PageDown", "PageUp", "Home", "End", "ArrowDown", "ArrowUp"].includes(event.key)) {
            markManualScroll();
          }
        });

        (async () => {
          try {
            await loadSnapshot();
            connectEvents();
          } catch (_error) {
            setStatus("Unable to load snapshot");
            showWarning("Failed to fetch initial preview snapshot. Check token and active session.");
          }
        })();
      })();
    </script>
  </body>
</html>
